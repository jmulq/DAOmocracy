schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Candidate {
  id: ID!
  name: String!
  party: String!
  votes: BigInt!
  election: Election!
}

input Candidate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  party: String
  party_not: String
  party_gt: String
  party_lt: String
  party_gte: String
  party_lte: String
  party_in: [String!]
  party_not_in: [String!]
  party_contains: String
  party_contains_nocase: String
  party_not_contains: String
  party_not_contains_nocase: String
  party_starts_with: String
  party_starts_with_nocase: String
  party_not_starts_with: String
  party_not_starts_with_nocase: String
  party_ends_with: String
  party_ends_with_nocase: String
  party_not_ends_with: String
  party_not_ends_with_nocase: String
  votes: BigInt
  votes_not: BigInt
  votes_gt: BigInt
  votes_lt: BigInt
  votes_gte: BigInt
  votes_lte: BigInt
  votes_in: [BigInt!]
  votes_not_in: [BigInt!]
  election: String
  election_not: String
  election_gt: String
  election_lt: String
  election_gte: String
  election_lte: String
  election_in: [String!]
  election_not_in: [String!]
  election_contains: String
  election_contains_nocase: String
  election_not_contains: String
  election_not_contains_nocase: String
  election_starts_with: String
  election_starts_with_nocase: String
  election_not_starts_with: String
  election_not_starts_with_nocase: String
  election_ends_with: String
  election_ends_with_nocase: String
  election_not_ends_with: String
  election_not_ends_with_nocase: String
  election_: Election_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Candidate_filter]
  or: [Candidate_filter]
}

enum Candidate_orderBy {
  id
  name
  party
  votes
  election
  election__id
  election__candidatesCount
  election__votersCount
}

type DAO {
  id: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  name: String!
  description: String!
  members(skip: Int = 0, first: Int = 100, orderBy: MemberDao_orderBy, orderDirection: OrderDirection, where: MemberDao_filter): [MemberDao!]
  proposers(skip: Int = 0, first: Int = 100, orderBy: ProposerDao_orderBy, orderDirection: OrderDirection, where: ProposerDao_filter): [ProposerDao!]
  proposals(skip: Int = 0, first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, where: Proposal_filter): [Proposal!]
  daoRegistry: DAORegistry
}

type DAOAdded {
  id: Bytes!
  daoAddress: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input DAOAdded_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  daoAddress: Bytes
  daoAddress_not: Bytes
  daoAddress_gt: Bytes
  daoAddress_lt: Bytes
  daoAddress_gte: Bytes
  daoAddress_lte: Bytes
  daoAddress_in: [Bytes!]
  daoAddress_not_in: [Bytes!]
  daoAddress_contains: Bytes
  daoAddress_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DAOAdded_filter]
  or: [DAOAdded_filter]
}

enum DAOAdded_orderBy {
  id
  daoAddress
  blockNumber
  blockTimestamp
  transactionHash
}

type DAORegistry {
  id: Bytes!
  daos(skip: Int = 0, first: Int = 100, orderBy: DAO_orderBy, orderDirection: OrderDirection, where: DAO_filter): [DAO!]!
}

input DAORegistry_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  daos_: DAO_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DAORegistry_filter]
  or: [DAORegistry_filter]
}

enum DAORegistry_orderBy {
  id
  daos
}

type DAORemoved {
  id: Bytes!
  daoAddress: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input DAORemoved_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  daoAddress: Bytes
  daoAddress_not: Bytes
  daoAddress_gt: Bytes
  daoAddress_lt: Bytes
  daoAddress_gte: Bytes
  daoAddress_lte: Bytes
  daoAddress_in: [Bytes!]
  daoAddress_not_in: [Bytes!]
  daoAddress_contains: Bytes
  daoAddress_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DAORemoved_filter]
  or: [DAORemoved_filter]
}

enum DAORemoved_orderBy {
  id
  daoAddress
  blockNumber
  blockTimestamp
  transactionHash
}

input DAO_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  members_: MemberDao_filter
  proposers_: ProposerDao_filter
  proposals_: Proposal_filter
  daoRegistry: String
  daoRegistry_not: String
  daoRegistry_gt: String
  daoRegistry_lt: String
  daoRegistry_gte: String
  daoRegistry_lte: String
  daoRegistry_in: [String!]
  daoRegistry_not_in: [String!]
  daoRegistry_contains: String
  daoRegistry_contains_nocase: String
  daoRegistry_not_contains: String
  daoRegistry_not_contains_nocase: String
  daoRegistry_starts_with: String
  daoRegistry_starts_with_nocase: String
  daoRegistry_not_starts_with: String
  daoRegistry_not_starts_with_nocase: String
  daoRegistry_ends_with: String
  daoRegistry_ends_with_nocase: String
  daoRegistry_not_ends_with: String
  daoRegistry_not_ends_with_nocase: String
  daoRegistry_: DAORegistry_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DAO_filter]
  or: [DAO_filter]
}

enum DAO_orderBy {
  id
  blockNumber
  blockTimestamp
  transactionHash
  name
  description
  members
  proposers
  proposals
  daoRegistry
  daoRegistry__id
}

type Election {
  id: Bytes!
  candidates(skip: Int = 0, first: Int = 100, orderBy: Candidate_orderBy, orderDirection: OrderDirection, where: Candidate_filter): [Candidate!]
  candidatesCount: BigInt!
  voters(skip: Int = 0, first: Int = 100, orderBy: Voter_orderBy, orderDirection: OrderDirection, where: Voter_filter): [Voter!]
  votersCount: BigInt!
}

input Election_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  candidates_: Candidate_filter
  candidatesCount: BigInt
  candidatesCount_not: BigInt
  candidatesCount_gt: BigInt
  candidatesCount_lt: BigInt
  candidatesCount_gte: BigInt
  candidatesCount_lte: BigInt
  candidatesCount_in: [BigInt!]
  candidatesCount_not_in: [BigInt!]
  voters_: Voter_filter
  votersCount: BigInt
  votersCount_not: BigInt
  votersCount_gt: BigInt
  votersCount_lt: BigInt
  votersCount_gte: BigInt
  votersCount_lte: BigInt
  votersCount_in: [BigInt!]
  votersCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Election_filter]
  or: [Election_filter]
}

enum Election_orderBy {
  id
  candidates
  candidatesCount
  voters
  votersCount
}

"""
8 bytes signed integer

"""
scalar Int8

type Member {
  id: Bytes!
  daos(skip: Int = 0, first: Int = 100, orderBy: MemberDao_orderBy, orderDirection: OrderDirection, where: MemberDao_filter): [MemberDao!]
}

type MemberDao {
  id: Bytes!
  member: Member!
  dao: DAO!
}

input MemberDao_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  member: String
  member_not: String
  member_gt: String
  member_lt: String
  member_gte: String
  member_lte: String
  member_in: [String!]
  member_not_in: [String!]
  member_contains: String
  member_contains_nocase: String
  member_not_contains: String
  member_not_contains_nocase: String
  member_starts_with: String
  member_starts_with_nocase: String
  member_not_starts_with: String
  member_not_starts_with_nocase: String
  member_ends_with: String
  member_ends_with_nocase: String
  member_not_ends_with: String
  member_not_ends_with_nocase: String
  member_: Member_filter
  dao: String
  dao_not: String
  dao_gt: String
  dao_lt: String
  dao_gte: String
  dao_lte: String
  dao_in: [String!]
  dao_not_in: [String!]
  dao_contains: String
  dao_contains_nocase: String
  dao_not_contains: String
  dao_not_contains_nocase: String
  dao_starts_with: String
  dao_starts_with_nocase: String
  dao_not_starts_with: String
  dao_not_starts_with_nocase: String
  dao_ends_with: String
  dao_ends_with_nocase: String
  dao_not_ends_with: String
  dao_not_ends_with_nocase: String
  dao_: DAO_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MemberDao_filter]
  or: [MemberDao_filter]
}

enum MemberDao_orderBy {
  id
  member
  member__id
  dao
  dao__id
  dao__blockNumber
  dao__blockTimestamp
  dao__transactionHash
  dao__name
  dao__description
}

input Member_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  daos_: MemberDao_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Member_filter]
  or: [Member_filter]
}

enum Member_orderBy {
  id
  daos
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Proposal {
  id: Bytes!
  title: String!
  description: String!
  proposalState: ProposalState!
  options(skip: Int = 0, first: Int = 100, orderBy: ProposalOption_orderBy, orderDirection: OrderDirection, where: ProposalOption_filter): [ProposalOption!]!
  dao: DAO!
  proposer: Proposer!
}

type ProposalOption {
  id: ID!
  proposal: Proposal!
  name: String!
  description: String!
  voteCount: BigInt!
}

input ProposalOption_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  proposal: String
  proposal_not: String
  proposal_gt: String
  proposal_lt: String
  proposal_gte: String
  proposal_lte: String
  proposal_in: [String!]
  proposal_not_in: [String!]
  proposal_contains: String
  proposal_contains_nocase: String
  proposal_not_contains: String
  proposal_not_contains_nocase: String
  proposal_starts_with: String
  proposal_starts_with_nocase: String
  proposal_not_starts_with: String
  proposal_not_starts_with_nocase: String
  proposal_ends_with: String
  proposal_ends_with_nocase: String
  proposal_not_ends_with: String
  proposal_not_ends_with_nocase: String
  proposal_: Proposal_filter
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  voteCount: BigInt
  voteCount_not: BigInt
  voteCount_gt: BigInt
  voteCount_lt: BigInt
  voteCount_gte: BigInt
  voteCount_lte: BigInt
  voteCount_in: [BigInt!]
  voteCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ProposalOption_filter]
  or: [ProposalOption_filter]
}

enum ProposalOption_orderBy {
  id
  proposal
  proposal__id
  proposal__title
  proposal__description
  proposal__proposalState
  name
  description
  voteCount
}

enum ProposalState {
  Active
  Closed
}

input Proposal_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  title: String
  title_not: String
  title_gt: String
  title_lt: String
  title_gte: String
  title_lte: String
  title_in: [String!]
  title_not_in: [String!]
  title_contains: String
  title_contains_nocase: String
  title_not_contains: String
  title_not_contains_nocase: String
  title_starts_with: String
  title_starts_with_nocase: String
  title_not_starts_with: String
  title_not_starts_with_nocase: String
  title_ends_with: String
  title_ends_with_nocase: String
  title_not_ends_with: String
  title_not_ends_with_nocase: String
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  proposalState: ProposalState
  proposalState_not: ProposalState
  proposalState_in: [ProposalState!]
  proposalState_not_in: [ProposalState!]
  options_: ProposalOption_filter
  dao: String
  dao_not: String
  dao_gt: String
  dao_lt: String
  dao_gte: String
  dao_lte: String
  dao_in: [String!]
  dao_not_in: [String!]
  dao_contains: String
  dao_contains_nocase: String
  dao_not_contains: String
  dao_not_contains_nocase: String
  dao_starts_with: String
  dao_starts_with_nocase: String
  dao_not_starts_with: String
  dao_not_starts_with_nocase: String
  dao_ends_with: String
  dao_ends_with_nocase: String
  dao_not_ends_with: String
  dao_not_ends_with_nocase: String
  dao_: DAO_filter
  proposer: String
  proposer_not: String
  proposer_gt: String
  proposer_lt: String
  proposer_gte: String
  proposer_lte: String
  proposer_in: [String!]
  proposer_not_in: [String!]
  proposer_contains: String
  proposer_contains_nocase: String
  proposer_not_contains: String
  proposer_not_contains_nocase: String
  proposer_starts_with: String
  proposer_starts_with_nocase: String
  proposer_not_starts_with: String
  proposer_not_starts_with_nocase: String
  proposer_ends_with: String
  proposer_ends_with_nocase: String
  proposer_not_ends_with: String
  proposer_not_ends_with_nocase: String
  proposer_: Proposer_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Proposal_filter]
  or: [Proposal_filter]
}

enum Proposal_orderBy {
  id
  title
  description
  proposalState
  options
  dao
  dao__id
  dao__blockNumber
  dao__blockTimestamp
  dao__transactionHash
  dao__name
  dao__description
  proposer
  proposer__id
}

type Proposer {
  id: Bytes!
  daos(skip: Int = 0, first: Int = 100, orderBy: ProposerDao_orderBy, orderDirection: OrderDirection, where: ProposerDao_filter): [ProposerDao!]
  proposals(skip: Int = 0, first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, where: Proposal_filter): [Proposal!]!
}

type ProposerDao {
  id: Bytes!
  proposer: Proposer!
  dao: DAO!
}

input ProposerDao_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  proposer: String
  proposer_not: String
  proposer_gt: String
  proposer_lt: String
  proposer_gte: String
  proposer_lte: String
  proposer_in: [String!]
  proposer_not_in: [String!]
  proposer_contains: String
  proposer_contains_nocase: String
  proposer_not_contains: String
  proposer_not_contains_nocase: String
  proposer_starts_with: String
  proposer_starts_with_nocase: String
  proposer_not_starts_with: String
  proposer_not_starts_with_nocase: String
  proposer_ends_with: String
  proposer_ends_with_nocase: String
  proposer_not_ends_with: String
  proposer_not_ends_with_nocase: String
  proposer_: Proposer_filter
  dao: String
  dao_not: String
  dao_gt: String
  dao_lt: String
  dao_gte: String
  dao_lte: String
  dao_in: [String!]
  dao_not_in: [String!]
  dao_contains: String
  dao_contains_nocase: String
  dao_not_contains: String
  dao_not_contains_nocase: String
  dao_starts_with: String
  dao_starts_with_nocase: String
  dao_not_starts_with: String
  dao_not_starts_with_nocase: String
  dao_ends_with: String
  dao_ends_with_nocase: String
  dao_not_ends_with: String
  dao_not_ends_with_nocase: String
  dao_: DAO_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ProposerDao_filter]
  or: [ProposerDao_filter]
}

enum ProposerDao_orderBy {
  id
  proposer
  proposer__id
  dao
  dao__id
  dao__blockNumber
  dao__blockTimestamp
  dao__transactionHash
  dao__name
  dao__description
}

input Proposer_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  daos_: ProposerDao_filter
  proposals_: Proposal_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Proposer_filter]
  or: [Proposer_filter]
}

enum Proposer_orderBy {
  id
  daos
  proposals
}

type Query {
  daoadded(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOAdded
  daoaddeds(
    skip: Int = 0
    first: Int = 100
    orderBy: DAOAdded_orderBy
    orderDirection: OrderDirection
    where: DAOAdded_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAOAdded!]!
  daoremoved(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAORemoved
  daoremoveds(
    skip: Int = 0
    first: Int = 100
    orderBy: DAORemoved_orderBy
    orderDirection: OrderDirection
    where: DAORemoved_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAORemoved!]!
  daoregistry(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAORegistry
  daoregistries(
    skip: Int = 0
    first: Int = 100
    orderBy: DAORegistry_orderBy
    orderDirection: OrderDirection
    where: DAORegistry_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAORegistry!]!
  election(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Election
  elections(
    skip: Int = 0
    first: Int = 100
    orderBy: Election_orderBy
    orderDirection: OrderDirection
    where: Election_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Election!]!
  candidate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Candidate
  candidates(
    skip: Int = 0
    first: Int = 100
    orderBy: Candidate_orderBy
    orderDirection: OrderDirection
    where: Candidate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Candidate!]!
  voter(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Voter
  voters(
    skip: Int = 0
    first: Int = 100
    orderBy: Voter_orderBy
    orderDirection: OrderDirection
    where: Voter_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Voter!]!
  dao(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAO
  daos(
    skip: Int = 0
    first: Int = 100
    orderBy: DAO_orderBy
    orderDirection: OrderDirection
    where: DAO_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAO!]!
  member(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Member
  members(
    skip: Int = 0
    first: Int = 100
    orderBy: Member_orderBy
    orderDirection: OrderDirection
    where: Member_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Member!]!
  proposer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposer
  proposers(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposer_orderBy
    orderDirection: OrderDirection
    where: Proposer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposer!]!
  memberDao(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MemberDao
  memberDaos(
    skip: Int = 0
    first: Int = 100
    orderBy: MemberDao_orderBy
    orderDirection: OrderDirection
    where: MemberDao_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MemberDao!]!
  proposerDao(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposerDao
  proposerDaos(
    skip: Int = 0
    first: Int = 100
    orderBy: ProposerDao_orderBy
    orderDirection: OrderDirection
    where: ProposerDao_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposerDao!]!
  proposal(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  proposalOption(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalOption
  proposalOptions(
    skip: Int = 0
    first: Int = 100
    orderBy: ProposalOption_orderBy
    orderDirection: OrderDirection
    where: ProposalOption_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposalOption!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  daoadded(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOAdded
  daoaddeds(
    skip: Int = 0
    first: Int = 100
    orderBy: DAOAdded_orderBy
    orderDirection: OrderDirection
    where: DAOAdded_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAOAdded!]!
  daoremoved(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAORemoved
  daoremoveds(
    skip: Int = 0
    first: Int = 100
    orderBy: DAORemoved_orderBy
    orderDirection: OrderDirection
    where: DAORemoved_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAORemoved!]!
  daoregistry(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAORegistry
  daoregistries(
    skip: Int = 0
    first: Int = 100
    orderBy: DAORegistry_orderBy
    orderDirection: OrderDirection
    where: DAORegistry_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAORegistry!]!
  election(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Election
  elections(
    skip: Int = 0
    first: Int = 100
    orderBy: Election_orderBy
    orderDirection: OrderDirection
    where: Election_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Election!]!
  candidate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Candidate
  candidates(
    skip: Int = 0
    first: Int = 100
    orderBy: Candidate_orderBy
    orderDirection: OrderDirection
    where: Candidate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Candidate!]!
  voter(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Voter
  voters(
    skip: Int = 0
    first: Int = 100
    orderBy: Voter_orderBy
    orderDirection: OrderDirection
    where: Voter_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Voter!]!
  dao(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAO
  daos(
    skip: Int = 0
    first: Int = 100
    orderBy: DAO_orderBy
    orderDirection: OrderDirection
    where: DAO_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAO!]!
  member(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Member
  members(
    skip: Int = 0
    first: Int = 100
    orderBy: Member_orderBy
    orderDirection: OrderDirection
    where: Member_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Member!]!
  proposer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposer
  proposers(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposer_orderBy
    orderDirection: OrderDirection
    where: Proposer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposer!]!
  memberDao(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MemberDao
  memberDaos(
    skip: Int = 0
    first: Int = 100
    orderBy: MemberDao_orderBy
    orderDirection: OrderDirection
    where: MemberDao_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MemberDao!]!
  proposerDao(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposerDao
  proposerDaos(
    skip: Int = 0
    first: Int = 100
    orderBy: ProposerDao_orderBy
    orderDirection: OrderDirection
    where: ProposerDao_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposerDao!]!
  proposal(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Proposal
  proposals(
    skip: Int = 0
    first: Int = 100
    orderBy: Proposal_orderBy
    orderDirection: OrderDirection
    where: Proposal_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Proposal!]!
  proposalOption(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProposalOption
  proposalOptions(
    skip: Int = 0
    first: Int = 100
    orderBy: ProposalOption_orderBy
    orderDirection: OrderDirection
    where: ProposalOption_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ProposalOption!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Voter {
  id: Bytes!
  election: Election!
  votedFor: ID!
}

input Voter_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  election: String
  election_not: String
  election_gt: String
  election_lt: String
  election_gte: String
  election_lte: String
  election_in: [String!]
  election_not_in: [String!]
  election_contains: String
  election_contains_nocase: String
  election_not_contains: String
  election_not_contains_nocase: String
  election_starts_with: String
  election_starts_with_nocase: String
  election_not_starts_with: String
  election_not_starts_with_nocase: String
  election_ends_with: String
  election_ends_with_nocase: String
  election_not_ends_with: String
  election_not_ends_with_nocase: String
  election_: Election_filter
  votedFor: ID
  votedFor_not: ID
  votedFor_gt: ID
  votedFor_lt: ID
  votedFor_gte: ID
  votedFor_lte: ID
  votedFor_in: [ID!]
  votedFor_not_in: [ID!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Voter_filter]
  or: [Voter_filter]
}

enum Voter_orderBy {
  id
  election
  election__id
  election__candidatesCount
  election__votersCount
  votedFor
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}